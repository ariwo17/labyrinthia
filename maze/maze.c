#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "maze.h"

void loadBgImage(struct canvas *maze)
{
    char* image = maze->backgroundImage;
    char* fileDirectory = concat("./maze/backgrounds/", image, ".png");
    displayImage(fileDirectory, 0, 0);
    //printf("Background image loaded at %s", fileDirectory);
}

void initializeCanvas(struct canvas *maze)
{
    int width = maze->gridSize[0];
    int height = maze->gridSize[1];
    int offset = maze->gridOffset;
    int length = maze->cellSideLength;
    setWindowSize(2 * offset + width * length, 2 * offset + height * length);
    background();
    setColour(maze->backgroundColour);
    if(maze->backgroundImage != NULL)
    {
        loadBgImage(maze);
    }
    fillRect(0, 0, 2 * offset + width * length, 2 * offset + height * length);
    setColour(maze->gridLineColour);
    drawRect(offset, offset, width * length, height * length);

}

void populateMaze(struct canvas *maze, FILE *filePointer){
    int markerX = maze->markerPoint[0];
    int markerY = maze->markerPoint[1];
    // Maybe use malloc(), alloc(), realloc() & free() to make sure only the NECESSARY amount of cells is recorded in the matrix
    memset(maze->mazeMap, emptyCell, sizeof maze->mazeMap);
    int x, y = 0;
    for (int i = 0; i < maze->numObstacles; i++) {
        char obstacle = fscanf(filePointer, "%d %d\n", &x, &y);
        maze->mazeMap[x][y] = 1;
    }
    maze->mazeMap[markerX][markerY] = 2;
}

int coordToPixels(struct canvas *maze, int coord)
{
    int offset = maze->gridOffset;
    int length = maze->cellSideLength;
    int p = (length * coord) + offset;
    return p;
}

int isObstacle(struct canvas *maze, int xCoord, int yCoord)
{
    if(maze->mazeMap[xCoord][yCoord] == obstacle) return 1;
    else return 0;
}

int isMarker(struct canvas *maze, int xCoord, int yCoord)
{
    if(maze->mazeMap[xCoord][yCoord] == marker) return 1;
    else return 0;
}

int isVisited(struct canvas *maze, int xCoord, int yCoord)
{
    if(maze->mazeMap[xCoord][yCoord] == visited) return 1;
    else return 0;
}

void tracePoint(struct canvas *maze, struct shape *character, int i)
{
    int x = character->x;
    int y = character->y;
    int w = maze->gridLineWidth;
    double length = character->sideLength - w;
    double angle = character->angle;
    character->xCoords[i] = x;
    character->yCoords[i] = y;
    character->x += (int)round(cos(convertToRadians(angle)) * length);
    character->y += (int)round(sin(convertToRadians(angle)) * length);
}

void generateVertices(struct canvas *maze, struct shape *character, struct robot *robot)
{
    int n;
    for(n=0; n<character->numberOfSides; n++)
    {
        tracePoint(maze, character, n);
        character->angle += 360.0 / character->numberOfSides;
        ////printf("(%d, %d)\n",character->xCoords[n], character->yCoords[n]);
    }
}

void plotObject(enum objectType object, struct canvas *maze, int xCoord, int yCoord)
{
    int x = coordToPixels(maze, xCoord);
    int y = coordToPixels(maze, yCoord);
    int length = maze->cellSideLength;
    int w = maze->gridLineWidth;
    setColour(maze->gridLineColour);
    fillRect(x, y, length, length);
    switch(object)
    {
        case obstacle:
            setColour(maze->obstacleColour);
            break;
        case marker:
            setColour(maze->markerColour);
            break;
        case visited:
            setColour(magenta);
            break;
        default:
            setColour(maze->gridColour);
            break;
    }
    fillRect(x + w, y + w, length - 2 * w, length - 2 * w);
}

void mazeMapToObject(struct canvas *maze, int xCoord, int yCoord)
{
    if(isObstacle(maze, xCoord, yCoord)) plotObject(obstacle, maze, xCoord, yCoord);
    else if(isMarker(maze, xCoord, yCoord)) plotObject(marker, maze, xCoord, yCoord);
    else if(isVisited(maze, xCoord, yCoord)) plotObject(visited, maze, xCoord, yCoord);
    else plotObject(emptyCell, maze, xCoord, yCoord);
}

void createMazeMappings(struct canvas *maze)
{
    int width = maze->gridSize[0];
    int height = maze->gridSize[1];
    int x, y;
    for(y=0; y<height; y++)
    {
        for(x=0; x<width; x++)
        {
            mazeMapToObject(maze, x, y);
        }
    }
}

void generateRobot(struct canvas *maze, struct shape *character, struct robot *robot)
{
    ////printf("The tested x,y positions are %d %d\n", robot->position[0], robot->position[1]);
    int w = maze->gridLineWidth;
    character->x = coordToPixels(maze, robot->position[0]) + w;
    character->y = coordToPixels(maze, robot->position[1]);
    character->sideLength =maze->cellSideLength - 2 * w;
    character->backgroundColour = maze->robotColour;
    character->outlineColour = black;
    pointRobotDir(character, robot);
    // Non-square shapes generated by the regular polygon function I made will need to be calibrated with the grid
    if(character->numberOfSides != 4) setOffsetByDir(character, robot);
    generateVertices(maze, character, robot);
}

void plotRobot(struct canvas *maze, struct shape *character, struct robot *robot)
{
    foreground();
    generateRobot(maze, character, robot);
    setColour(character->backgroundColour);
    if(character->skin != NULL && character->numberOfSides == 4){
        showSkin(character, robot);
    } else {
        fillPolygon(character->numberOfSides, character->xCoords, character->yCoords);
        setColour(character->outlineColour);
        drawPolygon(character->numberOfSides, character->xCoords, character->yCoords);
    }
}

int atMarker(struct canvas *maze, struct robot *robot)
{
    int x = robot->position[0];
    int y = robot->position[1];
    return isMarker(maze, x, y);
}

int atEdge(struct canvas *maze, struct robot *robot)
{
    int x = robot->position[0];
    int y = robot->position[1];
    int edgeX = maze->gridSize[0] - 1;
    int edgeY = maze->gridSize[1] - 1;
    switch(robot->direction)
    {
        case north:
            if (y == 0) return 1;
            else return 0;
        case west:
            if (x == edgeX) return 1;
            else return 0;
        case south:
            if (y == edgeY) return 1;
            else return 0;
        case east:
            if (x == 0) return 1;
            else return 0;
    }
    return 0;
}

int canMoveForward(struct canvas *maze, struct robot *robot)
{
    int x = robot->position[0];
    int y = robot->position[1];
    if(!atEdge(maze, robot))
    {
        switch(robot->direction)
        {
            case north:
                return !(isObstacle(maze, x, y - 1) || isVisited(maze, x, y - 1));
            case west:
                return !(isObstacle(maze, x + 1, y) || isVisited(maze, x + 1, y));
            case south:
                return !(isObstacle(maze, x, y + 1) || isVisited(maze, x, y + 1));
            case east:
                return !(isObstacle(maze, x - 1, y) || isVisited(maze, x - 1, y));
        }
    }
    else return 0;
}

int canCarveForward(struct canvas *maze, struct robot *robot)
{
    int x = robot->position[0];
    int y = robot->position[1];
    if(!atEdge(maze, robot))
    {
        switch(robot->direction)
        {
            case north:
                return (isObstacle(maze, x, y - 1));
            case west:
                return (isObstacle(maze, x + 1, y));
            case south:
                return (isObstacle(maze, x, y + 1));
            case east:
                return (isObstacle(maze, x - 1, y));
        }
    }
    else return 0;
}

void refreshMaze(struct canvas *maze, struct shape *character, struct robot *robot, int animTick){
    //The following is just for test purposes, for tracing visited cells
//    background();
//    clear();
//    createMazeMappings(maze);
    foreground();
    sleep(animTick);
    clear();
    plotRobot(maze, character, robot);
}

void loadMaze(struct canvas *maze, struct shape *character, struct robot *robot) {
    char* fileDirectory = concat("../maze/sample_levels/", maze->levelName, ".txt");
    FILE *filePointer = fopen(fileDirectory, "r");
    if (filePointer == NULL) {
        //printf("No such level! \n");
    }
    fscanf(filePointer, "%d %d %d %d %d %d %d %s %d %d %u %d %d %d %d %d %d %d\n", &(maze->gridSize[0]), &(maze->gridSize[1]),
           &(maze->cellSideLength), &(maze->gridLineWidth), &(maze->gridOffset), &(maze->gridLineColour), &(maze->backgroundColour), maze->backgroundImage, &(maze->spawnPoint[0]),
           &(maze->spawnPoint[1]), &(maze->initDir), &(maze->markerPoint[0]), &(maze->markerPoint[1]), &(maze->robotColour),
           &(maze->gridColour), &(maze->obstacleColour), &(maze->markerColour), &(maze->numObstacles));
    populateMaze(maze, filePointer);
    fclose(filePointer);
    initializeCanvas(maze);
    createMazeMappings(maze);
    robot->position[0] = maze->spawnPoint[0];
    robot->position[1] = maze->spawnPoint[1];
    robot->direction = maze->initDir;
    plotRobot(maze, character, robot);
}

// For testing purposes, a local function will reduce the pain of file handling & is useful for the random generator
void loadMazeLocally(struct canvas *maze, struct shape *character, struct robot *robot)
{
    initializeCanvas(maze);
    createMazeMappings(maze);
    robot->position[0] = maze->spawnPoint[0];
    robot->position[1] = maze->spawnPoint[1];
    robot->direction = maze->initDir;
    plotRobot(maze, character, robot);
}